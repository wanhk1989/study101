基本概念

并发和并行的区别
  并行，parallel
  同时做某些事，可以互不干扰的同一时刻做几件事
  
  并发，concurrency
  也是同时做某些事，但是强调，一个时间段内有多件事情要处理
  
举个栗子：
  高速公路，双向4车道，所有车辆（数据）可以互不干扰地在自己的车道上行驶（传输），
  在同一时刻，每条车道上可能同时有车辆行驶，强调同一时刻发生，这就是并行
  
  乡村公路，一条车道，半幅路面出现了坑，交警指挥交通。
  众多车辆在这一时段要通过路面的事件，这就是并发。
  交警指挥，车辆排队通过另外半幅路面，一个方向放行三分钟，停止该方向放行，换另一个方向放行

上面列子中，车道类比为线程，交警类比为CPU，车辆行驶类别为任务

并发的解决方案
  “食堂打饭模型”
  中午12点，到饭点开饭了，大家都涌向食堂，这就是并发，如果人很多，就是高并发。

1、队列、缓冲区
  假设只有一个窗口，陆续涌入食堂的人，排队打菜是比较好的方式。所以排队（队列）是一种天然解决并发的方法。
  排队就是把人排成队列，先进先出，解决了资源使用的问题。
  排成的队列，其实就是一个缓冲地带，就是缓冲区。

  假设女生优先，那么这个窗口就得是两队，只要有女生来就可以先打饭，男生队列等着，女生队伍就是一个优先队列。
  
  例如queue模块的类Queue、LifoQueue、ProrityQueue
  
2、争抢
  只开一个窗口，有可能没有秩序，也就是谁挤进去就给谁打饭，挤到窗口的人占据窗口，直到打到饭菜离开。
  其他人继续争抢，抢到了就会有一个人占据着窗口，可以视为锁定窗口，窗口就不能为其他人提供服务了，这是一种锁机制。
  谁抢到资源就上锁，排他性的锁，其他人只能等候。
  
  争抢也是一种高并发解决方案，但是，这样不好，因为可能有人很长时间抢不到。
  
3、预处理
  如果排队的队伍很长，是因为每个人打菜等候的时间长，因为要吃的菜没有，需要现做，没打着不走开，锁定着窗口。
  食堂可以提前统计大多数人最爱吃的菜品，将最爱吃的80%热门菜品，提前做好，保证供应，20%冷门菜，现做。
  这样大多数人，就算锁定窗口，也很快就释放窗口了。
  
  一种提前加载用户需要的数据的思路，预处理思想，缓存常用
  
4、并行
  成百上千人同时来吃饭,一个队伍搞不定的，多开打饭窗口形成多个队列，如同开多个车道一 样，并行打菜。
  开窗口就得扩大食堂,得多雇人在每个个窗口提供服务,造成成本上升。
  日常可以通过购买更多服务器,或多开进程、线程实现并行处理,来解决并发问题。
  
  注意些都是水平扩展思想。
  注：
  如果线程在单CPU上处理,就不是并行了。
  但是多数服务器都是多CPU的，服务的部署往往是多机的、分布式的，这都是并行处理。

5、提速
  提高单个窗口的打饭速度，也是解决并发的方式。
  打饭人员提高工作技能,或为单个窗口配备更多的服务人员,都是提速的办法。
  提高单个CPU性能，或单个服务器安装更多的CPU。
  这是一种垂直扩展思想。

6、消息中间件
上地、西二旗地铁站外的九曲回肠的走廊，缓冲人流，进去之后再多口安检进站。
常见的消息中间件有RabbitMQ、ActiveMQ （ Apache ）、RocketMQ （阿里Apache ）、 kafka （ Apache ）等。
当然还有其他手段解决并发问题，但是已经列举除了最常用的解决方案，一般来说不同的并发场 景用不同的策略，而策略可能是多种方式的优化组合。
例如多开食堂（多地），也可以把食堂建设到宿舍生活区（就近），所以说，技术来源于生活。

进程和线程
在实现了线程的操作系统中,线程賤作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个程序的执行实例就是一个进程。
进程（Process ）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作作系统结构的基础。

进程和程序的关系
程序是源代码编译后的文件，而这些文件存放在磁盘上。当程序被操作系统加载到内存中,就是进程，进程中存放着指令和数据（资源），它也是线程的容器。

Linux进程有父进程、子进程，Windows的进程是平等关系。
线程，有时被称为轻量级进程（Lightweight Process , LWP ）,是程序执行流的最小单元。
一个标准的线程由线程ID ,当前指令指针（PC ）,寄存器集合和堆栈组成。
在许多系统中，创建一个线程比创建一个进程快10-100倍。

进程、线程的理解
现代操作系统提出进程的概念，每一个进程都认为自己独占所有的计算机硬件资源。
进程就是独立的王国，进程间不可以随便的共享数据。
线程就是省份，同一个进程内的线程可以共享进程的资源，每一个线程拥有自己独立的堆栈。
